## 纸牌程序设计【需求一】4-1
## 纸牌程序设计【需求一】4-1


4 杜家兑 1 4月10日修改
4 Dujiadui 1 Modified on April 10


本文讨论了纸牌程序设计的需求,包括主玩法基础逻辑、任务实现需求、程序设计架构要求以及编码规范。关键要点包括：1. 主玩法基础逻辑：初始有一张底牌,...
本文讨论了纸牌程序设计的需求，包括主玩法基础逻辑、任务实现需求、程序设计架构要求以及编码规范。关键要点包括：1. 主玩法基础逻辑：初始有一张底牌,...


## 一、需求概述
## 一、需求概述


## 1. 主玩法基础逻辑
## 1. 主玩法基础逻辑


初始有一张底牌,需要与主牌区的牌匹配消除
初始有一张底牌,需要与主牌区的牌匹配消除


<!-- Media -->



<img src="https://cdn.noedgeai.com/bo_d3dkn4k601uc738c8m1g_0.jpg?x=95&y=596&w=597&h=283&r=0"/>



<!-- Media -->



## 2. 区域分布
## 2. Regional Distribution


<!-- Media -->



<table><tr><td rowspan="4">纸牌区</td><td/><td>截图视频</td></tr><tr><td>- 主牌堆： 。 主游戏区域显示待消除的 牌面 。 所有纸牌呈现翻开或覆盖 状态,翻开的牌可直接操 作,覆盖状态需消除上方 牌后才能翻开。</td><td> <img src="https://cdn.noedgeai.com/bo_d3dkn4k601uc738c8m1g_0.jpg?x=571&y=1035&w=561&h=274&r=0"/> </td></tr><tr><td>- 底牌堆： 。用于接收符合规则的纸牌 (数字比当前牌面数字大 或小1)。 。 初始底牌为一张翻开的备 用牌。</td><td> <img src="https://cdn.noedgeai.com/bo_d3dkn4k601uc738c8m1g_0.jpg?x=570&y=1340&w=556&h=263&r=0"/> </td></tr><tr><td>- 备用牌堆： 。 玩家可从备用牌堆抽取新 牌补充底牌堆,直到备用 牌耗尽。</td><td> <img src="https://cdn.noedgeai.com/bo_d3dkn4k601uc738c8m1g_0.jpg?x=566&y=1618&w=568&h=262&r=0"/> </td></tr></table>
<table><tbody><tr><td rowspan="4">纸牌区</td><td></td><td>截图视频</td></tr><tr><td>- 主牌堆： 。主游戏区域显示待消除的牌面。所有纸牌呈现翻开或覆盖状态，翻开的牌可直接操作，覆盖状态需消除上方牌后才能翻开。</td><td> <img src="https://cdn.noedgeai.com/bo_d3dkn4k601uc738c8m1g_0.jpg?x=571&y=1035&w=561&h=274&r=0"/> </td></tr><tr><td>- 底牌堆： 。用于接收符合规则的纸牌(数字比当前牌面数字大或小1)。 。初始底牌为一张翻开的备用牌。</td><td> <img src="https://cdn.noedgeai.com/bo_d3dkn4k601uc738c8m1g_0.jpg?x=570&y=1340&w=556&h=263&r=0"/> </td></tr><tr><td>- 备用牌堆： 。玩家可从备用牌堆抽取新牌补充底牌堆，直到备用牌耗尽。</td><td> <img src="https://cdn.noedgeai.com/bo_d3dkn4k601uc738c8m1g_0.jpg?x=566&y=1618&w=568&h=262&r=0"/> </td></tr></tbody></table>


<!-- Media -->



## 3. 消除规则
## 3. Elimination Rules


<!-- Media -->



<!-- figureText: 消除规则 截图视频 备注 Conception 1. 选择主牌堆中翻开的纸牌,点击主牌堆中 的牌和底牌匹配 。数字必须比底牌数字大或小1。 。 如底牌为“8”,可匹配“7”或“9”。 -->



<img src="https://cdn.noedgeai.com/bo_d3dkn4k601uc738c8m1g_0.jpg?x=92&y=2000&w=1412&h=267&r=0"/>



<!-- Media -->



2. 纸牌消除无花色限制。
2. There is no suit restriction for card elimination.


3. 当主牌堆中无可匹配消除的纸牌时,玩家可以从备用牌翻张新牌。
3. When there are no cards in the main deck that can be matched for elimination, the player can flip a new card from the reserve deck.


## 二、任务实现需求
## II. Task Implementation Requirements


II 实现一个简单普通点击匹配以及回退功能；
II Implement a simple ordinary click matching and rollback function;


<!-- Media -->



<!-- figureText: 3A 4 0d -->



<img src="https://cdn.noedgeai.com/bo_d3dkn4k601uc738c8m1g_1.jpg?x=94&y=402&w=511&h=937&r=0"/>



<!-- Media -->



## 1. 需求
## 1. Requirements


## 1. 需求1：手牌区翻牌替换
## 1. Requirement 1: Flipping and replacing cards in the hand area


- 点击手牌区♥A,♥A会平移(简单MoveTo)到手牌区的顶部牌(♣4)并替换它作为新的顶部牌
- Click on the ♥A in the hand area, and the ♥A will move horizontally (simple MoveTo) to the top card (♣4) in the hand area and replace it as the new top card


## 2. 需求2：桌面牌和手牌区顶部牌匹配
## 2. Requirement 2: Matching the table card and the top card in the hand area


- 点击桌面牌的 ◆ 3,卡牌会和手牌区顶部的♣4进行匹配【桌面牌区的牌只要和手牌区顶部牌点数差1就可以匹配,无花色要求】,点击的桌面牌 ( ◆ 3) 会平移到手牌区的顶部牌 (♣4) 并替换它作为新的手牌区的顶部牌
- Click on the ◆ 3 on the table, and the card will be matched with the ♣4 at the top of the hand area [The cards in the table card area can be matched as long as the point difference from the top card in the hand area is 1, without suit requirements]. The clicked table card ( ◆ 3) will move horizontally to the top card (♣4) in the hand area and replace it as the new top card in the hand area


## 3. 需求3：回退功能
## 3. Requirement 3: Rollback function


场景：点击 ◆ 3 -> 点击♥A -> 点击♠2 后；连续多次点击 回退按钮 ,各卡牌需要反着平移(简单MoveTo)到原位置；直到无回退记录可回退；
Scenario: After clicking ◆ 3 -> clicking ♥A -> clicking ♠2; click the rollback button multiple times continuously, and each card needs to move horizontally in the reverse direction (simple MoveTo) to its original position; until there are no rollback records to roll back;


## 2. 开发环境及要求
## 2. Development Environment and Requirements


1. 开发环境: cocos2dx 3.17
1. Development environment: cocos2dx 3.17


## 2. 要求:
## 2. Requirements:


。 代码结构请借鉴并尽可能遵循程 三、序设计架构要求；达到代码结构可维护性和可扩展性。
. Please refer to and try to follow the program design architecture requirements for the code structure; achieve maintainability and scalability of the code structure.


。 如有程序设计文档交付更好；在文档里能将清楚在你的代码结构下未来怎么新加一个卡牌和一个新类型的回退功能是加分项
。 It would be better if there is a program design document delivered; being able to clearly explain in the document how to add a new card and a new type of rollback function in the future under your code structure is a plus point


。 代码结构和程序文档的更好的交付决定未来可以承接的需求量
。 代码结构和程序文档的更好的交付决定未来可以承接的需求量


## 3. 细节说明以及资源文件
## 3. 细节说明以及资源文件


## 1. 设计分辨率：1080*2080; 窗口大小 1080*2080
## 1. Design resolution: 1080*2080; Window size 1080*2080


---



		代码块
		代码块

1 glview = GLViewImpl::createWithRect("Test", cocos2d::Rect(0, 0, 1080, 2080), 0.5
1个glview = GLViewImpl::createWithRect("测试", 可可引擎（cocos2d）::矩形(0, 0, 1080, 2080), 0.5

2 glview->setDesignResolutionSize(1080, 2080, ResolutionPolicy::FIXED_WIDTH);
2 glview->设置设计分辨率大小(1080, 2080, 分辨率策略::固定宽度);


---



## 2. 主牌区和卡堆尺寸
## 2. 主牌区和卡堆尺寸


主牌区尺寸：1080*1500
主牌区尺寸：1080*1500


。 堆牌去尺寸： 1080*580
。 Stack card dimensions: 1080*580


## 3. 关卡配置文件
## 3. 关卡配置文件


代码块
代码块


---



\{


	"Playfield": [
	 “游戏场地”：[

		\{


			"CardFace": 12,
			“牌面”：12

			"CardSuit": 0,
			“牌面花色”：0

			"Position": \{"x": 250, "y": 1000\}
			“位置”：{"x": 250, "y": 1000}

		\},


		\{


			"CardFace": 2,
			“牌面”：2

			"CardSuit": 0,
			“花色”：0

			"Position": \{"x": 300, "y": 800\}
			“位置”：{"x": 300, "y": 800}

		\},


		\{


			"CardFace": 2,
			“牌面”：2

			"CardSuit": 1,
			“花色”：1

			"Position": \{"x": 350, "y": 600
			“位置”：{"x": 350, "y": 600

			\}


		\},


		\{


			"CardFace": 2,
			“牌面”：2

			"CardSuit": 0,
			“花色”：0

			"Position": \{"x": 850, "y": 1000\}
			“位置”：{"x": 850, "y": 1000}

		\},


		\{


			"CardFace": 2,
			“牌面”：2

			"CardSuit": 0,
			“花色”：0

			"Position": \{"x": 800, "y": 800\}
			“位置”：{"x": 800, "y": 800}

		\},


		\{


			"CardFace": 1,
			“牌面”：1

			"CardSuit": 3,
			“花色”：3

			"Position": \{"x": 750, "y": 600\}
			“位置”：{"x": 750, "y": 600}

		\}


	],


	"Stack": [
	“牌堆”：[

		\{


			"CardFace": 2,
			“牌面”：2

			"CardSuit": 0,
			“花色”：0

			"Position": \{"x": 0, "y": 0\}
			“位置”：{"x": 0, "y": 0}

		\},


		\{


			"CardFace": 0,
			“牌面”：0

			"CardSuit": 2,
			“花色”：2

			"Position": \{"x": 0, "y": 0\}
			“位置”：{"x": 0, "y": 0}

		\},


		\{


			"CardFace": 3,
			“牌面”：3

			"CardSuit": 0,
			“花色”：0

			"Position": \{"x": 0, "y": 0\}
			“位置"：{"x": 0, "y": 0}

		\}



---



]



\}



---



代码块
代码块

	// 花色类型
	// 花色类型

	enum CardSuitType
	枚举类型 花色类型

	\{


		CST_NONE = -1,
		CST_NONE = -1,

	$\mathsf{{CST}\_ {CLUBS}}$ ,, // 梅花
	$\mathsf{{CST}\_ {CLUBS}}$ ,, // 梅花

	CST_DIAMONDS, // 方块
	CST_DIAMONDS, // 方块

	CST_HEARTS, N // 红桃
	CST_HEARTS, N // 红桃

	CST_SPADES, // 黑桃
	 黑桃（CST_SPADES）

	CST_NUM_CARD_SUIT_TYPES
	 CST_NUM_CARD_SUIT_TYPES

\};


// 正面类型
// 正面类型

enum CardFaceType
枚举类型：牌面类型

\{


	CFT_NONE = -1,
	 无牌面（CFT_NONE）= -1

	CFT_ACE,
	 A牌（CFT_ACE）

	CFT_TWO,
	 2牌（CFT_TWO）

	CFT_THREE,
	 3牌（CFT_THREE）

	CFT_FOUR,
	 4牌（CFT_FOUR）

	CFT_FIVE,
	 5牌（CFT_FIVE）

	CFT_SIX,
	 6牌（CFT_SIX）

	CFT_SEVEN,
	 7牌（CFT_SEVEN）

	CFT_EIGHT,
	 8牌（CFT_EIGHT）

	CFT_NINE,
	 9牌（CFT_NINE）

	CFT_TEN,
	 10牌（CFT_TEN）

	CFT_JACK,
	 J牌（CFT_JACK）

	CFT_QUEEN ,
	 CFT_女王

	CFT_KING,
	 CFT_国王

	CFT_NUM_CARD_FACE_TYPES
	 CFT_牌面类型数量

\};



---



## 4. 图片资源文件
## 4. 图片资源文件


---



目 res.zip 230.02KB
文件res.zip 230.02KB


---



⑥



## 三、程序设计架构要求
## 三、程序设计架构要求


## !! 架构概述
## !! 架构概述


采用MVC架构,将视图、逻辑和数据分离,要求代码的可维护性和可扩展性。
采用MVC架构（Model-View-Controller），将视图、逻辑和数据分离，要求代码的可维护性和可扩展性。


## 1. 目录结构
## 1. 目录结构


---



代码块
代码块

	Classes/
	Classes/

	- configs/ # 所有静态配置相关类
	- configs/ # 所有静态配置相关类

	—— models/ # 运行时动态数据模型
	—— models/ # 运行时动态数据模型

					视图层,包含所有的UI展示组件
					视图层，包含所有的UI展示组件

	- - controllers/ # 控制器层,协调模型和视图
	- - controllers/ # 控制器层，协调模型和视图

					#管理器层,提供全局性的服务和功能(作为controllers的成员；可持有model数
					#管理器层，提供全局性的服务和功能(作为controllers的成员；可持有model数

	- services/ #服务层,提供无状态的服务,处理业务逻辑,不管理数据生命周期；(禁止持有mod
	-  - 服务层/ #服务层，提供无状态的服务，处理业务逻辑，不管理数据生命周期；(禁止持有mod

	—— utils/ # 工具类,提供通用功能
	 —— 工具类/ # 工具类，提供通用功能


---



## 1. configs/ - 静态配置相关类
## 1. 配置文件/ - 静态配置相关类


职责和边界: 所有静态配置相关类; 举例: 2 关卡配置
职责和边界: 所有静态配置相关类; 举例: 2 关卡配置


- configs/models/LevelConfig.h 关卡配置类 configs/loaders/LevelConfigLoader.h 配置加载逻辑卡牌ui资源配置
- 配置文件/模型/关卡配置.h 关卡配置类 配置文件/加载器/关卡配置加载器.h 配置加载逻辑卡牌ui资源配置


- configs/models/CardResConfig.h
- 配置文件/模型/卡牌资源配置.h


2. models/ - 数据模型层,包含游戏的核心数据结构职责和边界:
2. 模型/ - 数据模型层，包含游戏的核心数据结构职责和边界:


运行时动态数据模型层；存储游戏数据和状态举例:
运行时动态数据模型层；存储游戏数据和状态举例:


。 CardModel 卡牌
。 卡牌模型 卡牌


。 GameModel 游戏
。 游戏模型 游戏


。 UndoModel 回退数据
。 撤销模型 回退数据


## 3. views/ - 视图层,包含所有的UI展示组件
## 3. 视图/ - 视图层，包含所有的UI展示组件


职责和边界:
职责和边界:


视图层只负责显示和接收用户输入,不包含业务逻辑举例:
视图层只负责显示和接收用户输入，不包含业务逻辑举例:


。 CardView 卡牌
。 卡牌视图 卡牌


- GameView 游戏
- 游戏视图 游戏


## 4. controllers/ - 控制器层,协调模型和视图
## 4. 控制器/ - 控制器层，协调模型与视图


职责和边界:
职责与边界：


。 控制器层处理用户操作和业务逻辑,连接视图和模型
。控制器层处理用户操作与业务逻辑，连接视图与模型


举例
示例


。 GameController 管理整个游戏流程
。游戏控制器管理整个游戏流程


- CardController 处理卡片相关的具体逻辑
- 卡片控制器处理与卡片相关的具体逻辑


- Controllers 可能会依赖多个 Services 和Managers
- 控制器可能依赖多个服务和管理器


## 5. managers/ -管理器层
## 5. 管理器/ - 管理器层


职责和边界:
职责与边界：


。 主要作为controller的成员变量
。主要作为控制器的成员变量


。可持有model数据并对model数据进行加工
。可持有模型数据并对模型数据进行处理


쪽止空孤为单例模式
应为单例模式


。 禁止反向依赖controller(维护性差, 也不便单元测试)
。禁止反向依赖控制器（维护性差，也不便进行单元测试）


。 与其他模块的交互可以通过回调接口来实现
。与其他模块的交互可通过回调接口实现


。 可以提供全局性的服务和功能
。可提供全局性的服务和功能


举例:
示例：


。 UndoManager - 处理撤销功能
。撤销管理器 - 处理撤销功能


## 6. services/ - 服务层
## 6. services/ - 服务层


职责和边界:
职责和边界:


。 提供无状态的服务,处理业务逻辑,不管理数据生命周期【不持有数据】,而是通过参数操作数据或返回数据
。提供无状态的服务，处理业务逻辑，不管理数据生命周期【不持有数据】，而是通过参数操作数据或返回数据


- 可引用传参修改原始数据(Model)性能高
- 可引用传参修改原始数据(模型)性能高


- 可返回值为数据(如Model)赋值给调用方 性能低
- 可返回值为数据(如模型)赋值给调用方 性能低


实现可复用的通用功能
实现可复用的通用功能


。 处理跨多个控制器的共享功能
。处理跨多个控制器的共享功能


举例:
举例:


---



GameModelFromLevelGenerator
关卡生成器的游戏模型


---



- 将静态配置(LevelConfig)转换为动态运行时数据(GameModel),并处理卡牌随机生成策略等等
- 将静态配置(关卡配置)转换为动态运行时数据(游戏模型)，并处理卡牌随机生成策略等等


- Services不依赖 Controllers,而是提供基础服务
- 服务不依赖于控制器，而是提供基础服务


## 7. utils/ - 工具类,提供通用功能
## 7. utils/ - 工具类，提供通用功能


## 2. 组件间通信流程
## 2. 组件间通信流程


## 1. 用户UI交互流程
## 1. 用户界面交互流程


1. 用户点击UI元素：
1. 用户点击用户界面元素：


。 用户点击卡片等UI元素时,首先由View层(如CardView)捕获事件
。当用户点击卡片等UI元素时，首先由视图层（如卡片视图）捕获事件


2. View到Controller的事件传递：
2. 从视图到控制器的事件传递：


- 回调函数：Controller在初始化时向View注册回调函数,View触发回调通知Controller
- 回调函数：控制器在初始化时向视图注册回调函数，视图触发回调以通知控制器


3. Controller处理业务逻辑：
3. 控制器处理业务逻辑：


。 GameController或CardController接收到事件后,执行相应的业务逻辑
。游戏控制器或卡片控制器接收到事件后，执行相应的业务逻辑


在处理前,Controller可能会更新UndoModel(通过UndoService向UndoModel插入一条回滚记录数据)
在处理之前，控制器可能会更新撤销模型（通过撤销服务向撤销模型插入一条回滚记录数据）


。 处理逻辑结束后,Controller更新Model的状态 4. Controller更新View:
。处理逻辑结束后，控制器更新模型的状态 4. 控制器更新视图：


逻辑处理完成后,Controller调用View对应的动画接口
逻辑处理完成后，控制器调用视图对应的动画接口


例如,GameController调用GameView的playMatchAnimation匹配动画
例如，游戏控制器调用游戏视图的playMatchAnimation匹配动画


---



代码块
代码块

	bool GameController::handleCardClick(int cardId)\{
	bool GameController::handleCardClick(int cardId)\{

		if (!_gameModel) return false;
		if (!_gameModel) return false;

		//一些逻辑规则判断
		//一些逻辑规则判断

		...


		if (_gameView) \{
		if (_gameView) \{

			_gameView->playMatchAnimation(cardId);
			_gameView->playMatchAnimation(cardId);

		\}


		...


		return true;
		return true;

	\}



---



### 1.1 典型交互案例：点击卡片
### 1.1 典型交互案例：点击卡片


---



代码块
代码块

	用户点击桌面上的卡片
	用户点击桌面上的卡片

			$\downarrow$


	PlayFieldView的触摸事件监听器检测到点击
	PlayFieldView的触摸事件监听器检测到点击

			↓
			↓

	PlayFieldView调用_onCardClickCallback(cardId)回调函数
	PlayFieldView调用_onCardClickCallback(cardId)回调函数

	PlayFieldController::handleCardClick(cardId)处理点击事件：
	PlayFieldController::handleCardClick(cardId)处理点击事件：

	检查卡片是否满足移动条件
	检查卡片是否满足移动条件

			$\downarrow$


	如果满足条件
	如果满足条件

			$\downarrow$


	PlayFieldController::replaceTrayWithPlayFieldCard执行:
	PlayFieldController::replaceTrayWithPlayFieldCard执行:

	- 记录撤销操作
	- 记录撤销操作

	- 更新model数据
	- 更新model数据

	- 调用相应的vieww执行动画
	- 调用相应的vieww执行动画


---



## 2. 游戏初始化加载
## 2. 游戏初始化加载


---



代码块
代码块

	用户选择关卡(提供关卡ID,捕获关卡选择事件)
	用户选择关卡(提供关卡ID,捕获关卡选择事件)

			↓
			↓

	调用GameController::startGame(levelId)
	 调用游戏控制器::开始游戏(关卡ID)

			$\downarrow$


	GameController调用LevelConfigLoader::loadLevelConfig(levelId)获取LevelConfig
	GameController调用LevelConfigLoader::loadLevelConfig(关卡ID)来获取关卡配置

			$\downarrow$


	GameController使用GameModelFromLevelGenerator::generateGameModel生成GameModel
	游戏控制器使用关卡生成器的游戏模型::生成游戏模型来生成游戏模型

			$\downarrow$


	GameController初始化各子控制器：
	游戏控制器初始化各子控制器：

	PlayFieldController::init(...)
	游戏场地控制器::初始化(...) 

	StackController::init(...)
	堆栈控制器::初始化(...) 

	UndoManager::init(...)
	撤销管理器::初始化(...) 

	创建GameView并添加到父节点:
	创建游戏视图并添加到父节点:

	gameView = GameView::create(...)
	游戏视图 = 游戏视图::创建(...) 

	初始化各子控制器的视图:
	Initialize the views of each sub - controller:

	StackController::initView(...)
	堆栈控制器::初始化视图(...) 

PlayFieldController::initView(...)
游戏场地控制器::初始化视图(...)（PlayFieldController::initView(...)）

	$\downarrow$


GameView初始化UI:
游戏视图初始化用户界面:

设置初始布局
设置初始布局

	$\downarrow$


播放入场动画: ...
播放入场动画: ...


---



## 四、编码规范
## 四、编码规范


## 命名规范
## 命名规范


- 类名和文件名：大写字母开头
- 类名和文件名：大写字母开头


- 函数名和变量名：采用驼峰风格(小写字母开头)
- 函数名和变量名：采用驼峰风格(小写字母开头)


- 类的私有成员和方法: 以 _ 下划线开头
- 类的私有成员和方法: 以 _ 下划线开头


- 常量变量名：以小写字母 k 开头
- 常量变量名：以小写字母k开头


## 代码质量要求
## 代码质量要求


- 每个类必须在声明处添加类的注释,清晰描述类的功能、职责和使用场景
- 每个类必须在声明处添加类的注释,清晰描述类的功能、职责和使用场景


- 类的成员变量和公共方法必须添加规范的注释,说明其用途、参数和返回值
- 类的成员变量和公共方法必须添加规范的注释,说明其用途、参数和返回值


- 当函数代码超过50行；请重构。
- 当函数代码超过50行；请重构。


- 当类代码超过500行；请重构。
- 当类代码超过500行；请重构。


- 模块职责明确,遵循单一职责原则；要求代码的可维护性和可扩展性
- 模块职责明确,遵循单一职责原则；要求代码的可维护性和可扩展性


## 各模块具体规范
## 各模块具体规范


## models层
## models层


- 数据层,不包含复杂的业务逻辑
- 数据层,不包含复杂的业务逻辑


- 支持序列化和反序列化 (因为游戏支持存档恢复继续玩)
- 支持序列化和反序列化 (因为游戏支持存档恢复继续玩)


## views层
## views层


- UI视图层,负责界面展示
- UI视图层，负责界面展示


- 可持有const类型的controller指针和const类型的model指针
- 可持有const类型的控制器指针和const类型的模型指针


- 与其他模块的交互可以通过回调接口来实现
- 与其他模块的交互可以通过回调接口来实现


## controllers层
## controllers层


- 主要协调model和view之间的交互
- 主要协调模型和视图之间的交互


- 处理用户操作的业务逻辑
- 处理用户操作的业务逻辑


## managers层
## managers层


- 主要作为controller的成员变量
- 主要作为控制器的成员变量


- 可持有model数据并对model数据进行加工
- 可持有模型数据并对模型数据进行加工


- 禁止实现为单例模式
- 禁止实现为单例模式


- 禁止反向依赖controller(维护性差,也不便单元测试)
- 禁止反向依赖控制器(维护性差，也不便单元测试)


- 与其他模块的交互可以通过回调接口来实现
- 与其他模块的交互可以通过回调接口来实现


- 可以提供全局性的服务和功能
- 可以提供全局性的服务和功能


## services层
## services层


- 处理业务逻辑,不管理数据生命周期
- 处理业务逻辑，不管理数据生命周期


- 自身禁止持有数据,但可加工数据
- 自身禁止持有数据，但可加工数据


- 可以实现为单例或者提供静态方法
- 可以实现为单例或者提供静态方法


## utils层
## utils层


- 提供通用独立的辅助功能
- 提供通用独立的辅助功能


- 不涉及业务逻辑,完全独立
- 不涉及业务逻辑，完全独立